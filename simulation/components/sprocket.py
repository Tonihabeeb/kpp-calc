"""
Sprocket component for the KPP drivetrain system.
Handles the conversion from linear chain motion to rotational drive.
"""

import logging
import math
from typing import Optional

logger = logging.getLogger(__name__)


class DriveShaft:
    """
    Drive shaft component that connects to the sprocket and transmits rotational power.
    """

    def __init__(
        self, inertia: float = 100.0, max_torque: float = 10000.0, diameter: float = 0.2
    ):
        """
        Initialize the drive shaft.

        Args:
            inertia (float): Rotational inertia of the shaft (kg·m²)
            max_torque (float): Maximum torque the shaft can handle (N·m)
            diameter (float): Shaft diameter (m)
        """
        self.inertia = inertia
        self.max_torque = max_torque
        self.diameter = diameter

        # Dynamic properties
        self.angular_velocity = 0.0  # rad/s
        self.angular_acceleration = 0.0  # rad/s²
        self.torque = 0.0  # N·m
        self.power = 0.0  # W

        # Mechanical properties
        self.friction_coefficient = 0.01  # Bearing friction
        self.temperature = 20.0  # °C

    def update(self, applied_torque: float, dt: float):
        """
        Update the shaft dynamics based on applied torque.

        Args:
            applied_torque (float): Torque applied to the shaft (N·m)
            dt (float): Time step (s)
        """
        # Calculate friction losses
        friction_torque = self.friction_coefficient * abs(self.angular_velocity)

        # Net torque after friction
        if self.angular_velocity > 0:
            net_torque = applied_torque - friction_torque
        else:
            net_torque = applied_torque + friction_torque

        # Limit torque to maximum capacity
        net_torque = max(-self.max_torque, min(self.max_torque, net_torque))

        # Update angular acceleration and velocity
        self.angular_acceleration = net_torque / self.inertia
        self.angular_velocity += self.angular_acceleration * dt

        # Calculate power output
        self.power = self.torque * self.angular_velocity

        # Store the applied torque for reporting
        self.torque = applied_torque

        logger.debug(
            f"DriveShaft - Torque: {self.torque:.2f} N·m, "
            f"Speed: {self.angular_velocity:.2f} rad/s, "
            f"Power: {self.power:.2f} W"
        )

    def get_rpm(self) -> float:
        """Get angular velocity in RPM."""
        return self.angular_velocity * 60 / (2 * math.pi)

    def reset(self):
        """Reset the shaft to initial conditions."""
        self.angular_velocity = 0.0
        self.angular_acceleration = 0.0
        self.torque = 0.0
        self.power = 0.0


class Sprocket:
    """
    Sprocket component that converts chain tension into rotational torque.
    """

    def __init__(
        self, radius: float = 1.0, tooth_count: int = 20, position: str = "top"
    ):
        """
        Initialize the sprocket.

        Args:
            radius (float): Sprocket radius (m)
            tooth_count (int): Number of teeth on the sprocket
            position (str): Position in the system ('top' or 'bottom')
        """
        self.radius = radius
        self.tooth_count = tooth_count
        self.position = position

        # Dynamic properties
        self.angular_velocity = 0.0  # rad/s
        self.torque = 0.0  # N·m
        self.chain_tension = 0.0  # N

        # Create associated drive shaft with reduced inertia for better startup
        self.drive_shaft = DriveShaft(inertia=10.0)  # Reduced from default 100.0

        # Mechanical properties
        self.efficiency = 0.95  # Sprocket efficiency
        self.tooth_engagement_efficiency = 0.98  # Chain-sprocket engagement efficiency

    def calculate_torque_from_chain_tension(self, chain_tension: float) -> float:
        """
        Calculate torque generated by chain tension.

        Args:
            chain_tension (float): Total tension in the chain (N)

        Returns:
            float: Torque generated (N·m)
        """
        # DIRECTION FIX: Use absolute value to ensure positive torque generation
        # The direction of rotation is determined by the system dynamics, not the sign
        abs_tension = abs(chain_tension)
        
        # Basic torque calculation: T = F × r
        base_torque = abs_tension * self.radius

        # Apply efficiency losses
        effective_torque = (
            base_torque * self.efficiency * self.tooth_engagement_efficiency
        )

        return effective_torque

    def update(self, chain_tension: float, dt: float):
        """
        Update sprocket dynamics based on chain tension.

        Args:
            chain_tension (float): Tension in the chain (N)
            dt (float): Time step (s)
        """
        self.chain_tension = chain_tension

        # Calculate torque from chain tension
        self.torque = self.calculate_torque_from_chain_tension(chain_tension)

        # Update the drive shaft with this torque
        self.drive_shaft.update(self.torque, dt)

        # Synchronize angular velocity with drive shaft
        self.angular_velocity = self.drive_shaft.angular_velocity
        
        # SPEED LIMIT: Prevent unrealistic overspeed
        max_angular_velocity = 50.0  # rad/s (about 477 RPM - realistic for large sprocket)
        if abs(self.angular_velocity) > max_angular_velocity:
            self.angular_velocity = max_angular_velocity * (1 if self.angular_velocity > 0 else -1)
            self.drive_shaft.angular_velocity = self.angular_velocity

        logger.debug(
            f"Sprocket ({self.position}) - Chain Tension: {chain_tension:.2f} N, "
            f"Torque: {self.torque:.2f} N·m, "
            f"Speed: {self.get_rpm():.2f} RPM"
        )

    def get_rpm(self) -> float:
        """Get angular velocity in RPM."""
        return self.angular_velocity * 60 / (2 * math.pi)

    def get_chain_speed(self) -> float:
        """Get the linear speed of the chain at the sprocket."""
        return self.angular_velocity * self.radius

    def get_power_output(self) -> float:
        """Get mechanical power output."""
        return self.drive_shaft.power

    def reset(self):
        """Reset the sprocket to initial conditions."""
        self.angular_velocity = 0.0
        self.torque = 0.0
        self.chain_tension = 0.0
        self.drive_shaft.reset()
